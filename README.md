Caesar Cipher - Shift Logic in JavaScriptWhat is this?This is my personal implementation of the Caesar Cipher, one of the oldest and simplest encryption techniques. I built this to practice ASCII character manipulation and to understand how basic shift ciphers operate mathematically.How the Logic WorksInstead of using a simple lookup table, I used modular arithmetic to handle the character shifts. This ensures that if a shift goes past 'Z', it "wraps around" back to 'A'.The Math behind the code:For each character, the formula I used is:$$\text{NewChar} = ((\text{CurrentPos} - \text{Offset} + \text{Key}) \pmod{\text{Range}}) + \text{Offset}$$Features of my implementation:Uppercase (A-Z): Ranges from ASCII 65 to 90.Lowercase (a-z): Ranges from ASCII 97 to 122.Numbers (0-9): I added support for digits (ASCII 48-57) using a modulo 10.Special Characters: Support for symbols between ASCII 33 and 47 (modulo 14).Input Validation: The script checks if the key is a valid integer before running to prevent errors.Cybersecurity AnalysisAs a cybersecurity enthusiast, I know this cipher is strictly for educational purposes.Vulnerability: This is a substitution cipher with only 25 possible keys for the alphabet. It can be cracked in milliseconds using Brute Force (trying every key).Frequency Analysis: Just like the Polybius Square, it doesn't hide the patterns of the language. The most frequent letter in English or French will still be the most frequent in the ciphertext, just shifted.Modern use: Today, Caesar-style shifts (like ROT13) are only used for hiding spoilers in forums or as a basic obfuscation, never for real security.Technical DetailsLanguage: Vanilla JavaScript.Key Function: charCodeAt() and String.fromCharCode() for direct memory-to-character conversion.Modular Arithmetic: Used % 26 for letters and % 10 for numbers to ensure perfect "wrapping".How to useEnter your text.Provide a numeric key (the number of positions to shift).Check the result in the output field.
